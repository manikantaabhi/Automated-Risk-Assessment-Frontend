  import { Component, EventEmitter, Output, Input } from '@angular/core';
  import { CommonModule } from '@angular/common';
  import { MatDialogRef } from '@angular/material/dialog';
  import { FormsModule } from '@angular/forms';
  import { HttpClient, HttpClientModule } from '@angular/common/http';
  import { Router } from '@angular/router';
import { LoadingService } from '../../services/loading.service';
import { MatTooltipModule } from '@angular/material/tooltip';

  @Component({
    selector: 'app-search-popup',
    templateUrl: './vulnerability-popup.component.html',
    styleUrls: ['./vulnerability-popup.component.css'],
    imports: [CommonModule,FormsModule,HttpClientModule,MatTooltipModule]
  })
  export class VulnerabilityPopupComponent {

    makeSuggestions: string[] = [];
productSuggestions: string[] = [];
versionSuggestions: string[] = [];


showMakeSuggestions = false;
showProductSuggestions = false;
showVersionSuggestions = false;
    
    @Output() searchCompleted = new EventEmitter<boolean>();

    searchData = { make: '', productName: '', version: '', keywords: '' };
    selectedFile: File | null = null;

    isMakeInvalid = false;
isProductInvalid = false;
isVersionInvalid = false;

    constructor(private router:Router,private http:HttpClient,private dialogRef: MatDialogRef<VulnerabilityPopupComponent>,private loadingService:LoadingService) {}

    // Handles file selection
    onFileSelected(event: any) {
      this.selectedFile = event.target.files[0];
    }

    check(id: string) {
      const element = document.getElementById(id) as HTMLInputElement;
      if (element) {
        if (element.value.trim() === '') {
          element.style.border = '2px solid red';
          element.style.boxShadow = '0 0 5px rgba(255, 0, 0, 0.5)';
        } else {
          element.style.border = '';
          element.style.boxShadow = '';
        }
      }
    }
    
    
    // Handles search logic and emits event
    onSearch() {
      const elements = document.getElementsByClassName('mandatory');
for (let i = 0; i < elements.length; i++) {
  const input = elements[i] as HTMLElement;

  if ((input as HTMLInputElement).value.trim() === '') {
    input.style.border = '2px solid red';
    input.style.boxShadow = '0 0 5px rgba(255, 0, 0, 0.5)';
  } else {
    input.style.border = '';
    input.style.boxShadow = '';
  }
}

      this.isMakeInvalid = !this.searchData.make.trim();
      this.isProductInvalid = !this.searchData.productName.trim();
      this.isVersionInvalid = !this.searchData.version.trim();
    
      // If any field is invalid, stop the function
      if (this.isMakeInvalid || this.isProductInvalid || this.isVersionInvalid) {
        return;
      }

      this.loadingService.startLoading();
      let formData = new FormData();
      formData.append('make', this.searchData.make);
      formData.append('productName', this.searchData.productName);
      formData.append('version', this.searchData.version);
      formData.append('keywords', this.searchData.keywords);
      const apiUrl = 'http://localhost:8080/api/vulnerabilities/check';
    
      if (this.selectedFile) {
        formData.append('file', this.selectedFile);
      }
    
      this.http.post<any>(apiUrl, formData).subscribe(
        (response) => {
          //console.log("Full API Response:", response);

          this.loadingService.stopLoading();
          // Close dialog and return both vulnerabilities and inputData
          this.dialogRef.close({ vulnerabilities: response, inputData: { ...this.searchData } });
    
          // Navigate with state
          this.router.navigate(['/display-vulnerabilities'], { 
            state: { vulnerabilities: response, inputData: { ...this.searchData } } 
          });
        },
        (error) => {
          this.loadingService.stopLoading();
          console.error('Error fetching vulnerability data:', error);
        }
      );
    }
    
    fetchSuggestions(type: string, query: string) {
      let params = new URLSearchParams();
      params.set('q', query || '');  // Even empty string should trigger fetch
    
      if (type === 'product' && this.searchData.make) {
        params.set('make', this.searchData.make);
      }
    
      if (type === 'version') {
        if (this.searchData.make) {
          params.set('make', this.searchData.make);
        }
        if (this.searchData.productName) {
          params.set('product', this.searchData.productName);
        }
      }
    
      this.http.get<string[]>(`http://localhost:8080/api/suggestions/${type}?${params.toString()}`)
        .subscribe(suggestions => {
          //console.log(`Suggestions for ${type}:`, suggestions);
          if (type === 'make') {
            this.makeSuggestions = suggestions;
            this.showMakeSuggestions = true;
          } else if (type === 'product') {
            this.productSuggestions = suggestions;
            this.showProductSuggestions = true;
          } else if (type === 'version') {
            this.versionSuggestions = suggestions;
            this.showVersionSuggestions = true;
          }
        });
    }
    
    
    hideSuggestions(type: string) {
      setTimeout(() => {
        if (type === 'make') this.showMakeSuggestions = false;
        if (type === 'product') this.showProductSuggestions = false;
        if (type === 'version') this.showVersionSuggestions = false;
      }, 200); // Wait a little so user can click
    }
    
    selectSuggestion(type: string, value: string) {
      if (type === 'make') this.searchData.make = value;
      if (type === 'product') this.searchData.productName = value;
      if (type === 'version') this.searchData.version = value;
    
      this.hideSuggestions(type);
    }


    // Close the popup manually
    closeModal() {
      this.dialogRef.close();
    }
  }
